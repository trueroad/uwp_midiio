<!-- -*- coding: utf-8 -*- -->
# UWP MIDIIO ライブラリ (DLL)

[ Japanese (日本語) / [English](./README.md) ]

https://github.com/trueroad/uwp_midiio

[MIDIシーケンサー・MIDI編集ソフト『世界樹』
](https://openmidiproject.osdn.jp/Sekaiju.html)
を BLE MIDI (Bluetooth MIDI) 対応にできる
**UWP MIDIIO ライブラリ (DLL)**
です。

## はじめに

[世界樹](https://openmidiproject.osdn.jp/Sekaiju.html)
は、Windows で動作する
オープンソースの MIDI シーケンサ―・MIDI編集ソフトウェアです。
Windows が認識する MIDI ポートを介して楽器を接続して使うことができるので、
USB MIDI で接続している方も多いのではないでしょうか。
一方、Windows 10 は 2016 年頃から BLE MIDI (Bluetooth MIDI)
に対応しています。
しかし、残念ながら世界樹バージョン 7.5 （2022 年 8 月時点の最新版）は
USB MIDI を扱うことはできますが、BLE MIDI を扱うことができません。

世界樹は[
MIDIIO ライブラリ
](https://openmidiproject.osdn.jp/MIDIIOLibrary.html)
によって MIDI 入出力しています。
MIDIIO ライブラリは MME (Multi Media Extension) と呼ばれる
API 群を使って MIDI 入出力を実現していますが、
MME では BLE MIDI を扱うことができません。
Windows 10 で MIDI を扱う API には MME の他に後発の
UWP (Universal Windows Platform) 用 API 群があり、
BLE MIDI は UWP のみの対応になっているのです。

世界樹はオープン―ソース、MIDIIO ライブラリもオープンソースです。
では、MME に対応している MIDIIO ライブラリの代わりに、
UWP に対応するライブラリを作って差し替えてしまえば
世界樹を BLE MIDI 対応にできるのではないか？という発想の試みが、
この
**UWP MIDIIO ライブラリ (DLL)**
（以下、本ライブラリ）です。

もちろん、BLE MIDI だけではなく、従来の USB MIDI などにも対応しています。
また、UWP のメリットとしてマルチクライアント対応が強化されています。

なお、本ライブラリももちろんオープンソースで無保証です。
何か問題は発生した場合はご自分で解決するようにお願いいたします。

また、本ライブラリは、世界樹や
おーぷん MIDI ぷろじぇくと
の関係者とは独立して作成しております。
そのため、本ライブラリについて、あるいは本ライブラリをインストールした
環境における世界樹などの動作や使い方などについて、
おーぷん MIDI ぷろじぇくと
や、その関係者へ問い合わせることはおやめください。

## ビルド

Visual Studio Community 2019 でリリース版をビルドすると
`MIDIIO.dll` ができます。

## インストール

世界樹のフォルダにあるオリジナルの `MIDIIO.dll` のバックアップを取ってから、
置き換えてください。

## 使い方

BLE MIDI デバイスは、世界樹を起動する前に、
あらかじめ Windows の設定画面でペアリングを済ませておいてください。

世界樹を起動したら、メニューの
「設定」から「MIDI デバイスとインストゥルメント」を選び、
「MIDI デバイスとインストゥルメント」ダイアログを出します。
「MIDI 入力デバイス」タブまたは「MIDI 出力デバイス」タブで
「入力ポート」「出力ポート」のプルダウンを開くと
UWP で得られたポートの一覧が出てくるようになります。

一覧に出てくる名前は従来とは異なり、
本ライブラリ特有の「表示名」になります。
多くのポートは後ろに 16 進数 8 桁を角括弧で括ったものがつくので、
本ライブラリが動作しているか否かを判断できます。

BLE MIDI デバイスがペアリング済みであれば、
この一覧で選択できるようになります。
BLE MIDI 以外にも、
従来から扱うことのできた USB MIDI デバイスや
Microsoft GS Wavetable Synth も出てきて選択することができます。
MIDI Mapper は選択しても開くことができません
（元々 Windows 10 では使えません）。

なお、BLE MIDI デバイスを選択しても、
デバイスが圏外であったり電源が入っていなかったりすると
デバイスが開けない旨のエラーになります。
そういう場合は、電源が入っているか否か、
PC との距離や電波環境などを確認してみてください。

また、BLE MIDI デバイスによっては
電源投入後一定時間のみ接続可能なものがあり、
ある程度時間が経っているとデバイスが開けないエラーになることがあるようです。
そういう場合は一旦電源を切ってから再度電源投入するなどすると
使えるようになることがあります。

## MIDIIO ライブラリとの互換性

本ライブラリは[
MIDIIO ライブラリ
](https://openmidiproject.osdn.jp/MIDIIOLibrary.html)
の機能のうち、世界樹を動作させるために必要な最低限のみを実装しています。
MIDIIO ライブラリの仕様については MIDIIO
ライブラリ付属のドキュメントをご覧ください。

### 存在しない機能

MIDIIO ライブラリには存在するが、
本ライブラリには存在しない機能は以下の通りです。

* 32 bit 版はありません
* 以下の関数は実装していません
    + `MIDIOut_GetDeviceNameA`
    + `MIDIOut_OpenA`
    + `MIDIOut_ReopenA`
    + `MIDIOut_Reset`
    + `MIDIOut_PutByte`
    + `MIDIOut_PutBytes`
    + `MIDIOut_GetThisDeviceNameA`
    + `MIDIOut_GetThisDeviceNameW`
    + `MIDIIn_GetDeviceNameA`
    + `MIDIIn_OpenA`
    + `MIDIIn_ReopenA`
    + `MIDIIn_Reset`
    + `MIDIIn_GetByte`
    + `MIDIIn_GetBytes`
    + `MIDIIn_GetThisDeviceNameA`
    + `MIDIIn_GetThisDeviceNameW`
* `MIDIIn` 構造体、`MIDIOut` 構造体の
  以下のメンバは使用しておらず値も設定しません
    + `m_pDeviceHandle`
    + `m_lMode`
    + `m_pBuf`
    + `m_lBufSize`
    + `m_lReadPosition`
    + `m_lWritePosition`

### 存在する機能

MIDIIO ライブラリと挙動が異なるなど注意を要する点を挙げていきます。

#### `MIDIOut_GetDeviceNum` 関数

呼び出されたら、その都度
UWP MIDI で MIDI IN/OUT 双方のデバイスをスキャンします。
見つかったデバイスの名前と ID およびそこから生成した表示名の組み合わせを
DLL 内部に保持します。
デバイスの名前、ID、表示名については別項目をご覧ください。

MIDI IN/OUT デバイスは動的に変わる
（USB MIDI を接続した・外した、BLE MIDI をペアリングした・解除したなど）
ことがあるため、
呼び出すたびに返り値や DLL 内部に保持した情報が変わることがあります。

本関数を呼び出して MIDI OUT デバイス数を得てから
`MIDIOut_GetDeviceNameW` 関数で
すべての名前取得を完了するまでの間は、
本関数を再度呼び出さないようにしてください。
同一スレッド、異スレッド、いずれもダメです。

#### `MIDIOut_GetDeviceNameW` 関数

`MIDIOut_GetDeviceNum` 関数が生成して DLL 内部に保持した表示名を返します。
MIDIIO ライブラリでは
「デバイスの名前は通常 32 文字以下（ヌル文字含む）」
とありますが、本ライブラリではそのような制限がないため
もっと長い文字列になる可能性があります。
引数のバッファ長の方が短かった場合は切り詰めた文字列が得られます。
表示名については別項目をご覧ください。

`MIDIOut_GetDeviceNum` 関数を呼び出して MIDI OUT デバイス数を得てから
本関数で
すべての名前取得が完了するまでの間は、
`MIDIOut_GetDeviceNum` 関数を再度呼び出さないようにしてください。
同一スレッド、異スレッド、いずれもダメです。

#### `MIDIOut_OpenW` 関数

世界樹では使っていない関数ですが
`MIDIOut_ReopenW` 関数から呼ぶために実装しています。

引数として本ライブラリの `MIDIOut_GetDeviceNameW`
関数で得られた表示名を指定してください。

UWP MIDI では MIDI ポートを開くために名前ではなく ID が必要になるため、
引数で指定された表示名から DLL 内部に保持した対応する ID を探します。

一度も `MIDIOut_GetDeviceNum` 関数を呼び出していない場合は
表示名と ID の組み合わせを保持していないため
`MIDIOut_GetDeviceNum` 関数の内部処理を呼び出して同等の処理を行い、
表示名と ID の組み合わせを DLL 内部に保持します。

`MIDIOut_GetDeviceNameW` 関数で指定したバッファが短くて
表示名が切り詰められていても、前方一致するものがあれば該当として
その ID を使います。

ID を使って UWP MIDI で MIDI ポートを開きますが
BLE の接続などで時間がかかることがありますので、
タイムアウトとして 3 秒を指定
（`config.h` の `MIDI_PORT_OPEN_TIMEOUT`）
しています。
タイムアウトした場合は開けなかったという結果になります。

開くことができた MIDI ポートの情報については DLL 内部に保持しています。

ID、表示名については別項目をご覧ください。
返り値となる `MIDIOut` 構造体の扱いについては別項目をご覧ください。

#### `MIDIOut_Close` 関数

引数として本ライブラリの
`MIDIOut_OpenW` 関数または `MIDIOut_ReopenW` 関数の返り値以外は
指定しないでください。

DLL 内部に保持している、
開いている MIDI OUT ポートの一覧から指定されたものを探し、
そのポートを UWP MIDI で閉じた上で使用していたリソースを解放します。

引数となる `MIDIOut` 構造体の扱いについては別項目をご覧ください。

#### `MIDIOut_ReopenW` 関数

内部で `MIDIOut_Close` 関数と `MIDIOut_OpenW` 関数を呼んでいます。
そちらの項目をご覧ください。

#### `MIDIOut_PutMIDIMessage` 関数

MIDI OUT デバイス指定用の引数としては、本ライブラリの
`MIDIOut_OpenW` 関数または `MIDIOut_ReopenW` 関数の返り値以外は
指定しないでください。

引数となる `MIDIOut` 構造体の扱いについては別項目をご覧ください。

#### `MIDIIn_GetDeviceNum` 関数

`MIDIOut_GetDeviceNum` 関数とほぼ同様の挙動の MIDI IN 版ですが、
こちらは内部で MIDI IN デバイスのみをスキャンします
（`MIDIOut_GetDeviceNum` 関数は MIDI IN/OUT 双方をスキャンします）。
`MIDIOut_GetDeviceNum` 関数の項目もご覧ください。

本関数を呼び出して MIDI IN デバイス数を得てから
`MIDIIn_GetDeviceNameW` 関数で
すべての名前取得が完了するまでの間は、
本関数や `MIDIOut_GetDeviceNum` 関数を呼び出さないようにしてください。
同一スレッド、異スレッド、いずれもダメです。

#### `MIDIIn_GetDeviceNameW` 関数

`MIDIOut_GetDeviceNameW` 関数と同様の挙動の MIDI IN 版です。
`MIDIOut_GetDeviceNameW` 関数の項目もご覧ください。

`MIDIIn_GetDeviceNum` 関数を呼び出して MIDI IN デバイス数を得てから
本関数で
すべての名前取得が完了するまでの間は、
`MIDIIn_GetDeviceNum` 関数や `MIDIOut_GetDeviceNum`
関数を呼び出さないようにしてください。
同一スレッド、異スレッド、いずれもダメです。

#### `MIDIIn_OpenW` 関数

`MIDIOut_OpenW` 関数と同様の挙動の MIDI IN 版です。
`MIDIOut_OpenW` 関数の項目もご覧ください。
世界樹は使っていない関数ですが
`MIDIIn_ReopenW` 関数から呼ぶために実装しています。

引数として本ライブラリの `MIDIIn_GetDeviceNameW`
関数で得られた表示名を指定してください。

一度も `MIDIIn_GetDeviceNum` 関数または
`MIDIOut_GetDeviceNum` 関数を呼び出していない場合は
表示名と ID の組み合わせを保持していないため
`MIDIIn_GetDeviceNum` 関数の内部処理を呼び出して同等の処理を行い、
表示名と ID の組み合わせを DLL 内部に保持します。

`MIDIIn_GetDeviceNameW` 関数で指定したバッファが短くて
表示名が切り詰められていても、前方一致するものがあれば該当として
その ID を使います。

MIDI IN ポートを開くことができたら、
MIDI メッセージ受信イベント処理を登録します。
それにより MIDI メッセージを受信したら内部のキューにため込みます。
キューはメッセージ単位になっており、初期キューサイズは 8,192
（`config.h` の `DEFAULT_MIDI_IN_QUEUE_SIZE`）です。
キューがあふれた場合は最大キューサイズ 16,384
（`config.h` の `MAX_MIDI_IN_QUEUE_SIZE`）までは増加しますが、
それ以上は古いメッセージから捨てていきます。

返り値となる `MIDIIn` 構造体の扱いについては別項目をご覧ください。

#### `MIDIIn_Close` 関数

`MIDIOut_Close` 関数と同様の挙動の MIDI IN 版です。
`MIDIOut_Close` 関数の項目もご覧ください。

引数として本ライブラリの
`MIDIIn_OpenW` 関数または `MIDIIn_ReopenW` 関数の返り値以外は
指定しないでください。

DLL 内部に保持している、
開いている MIDI IN ポートの一覧から指定されたものを探し、
MIDI メッセージ受信イベント処理を登録解除し、
ポートを UWP MIDI で閉じた上で使用していたリソースを解放します。
残っていたキューも解放されます。

引数となる `MIDIIn` 構造体の扱いについては別項目をご覧ください。

#### `MIDIIn_ReopenW` 関数

内部で `MIDIIn_Close` 関数と `MIDIIn_OpenW` 関数を呼んでいます。
そちらの項目をご覧ください。

#### `MIDIIn_GetMIDIMessage` 関数

MIDI IN デバイス指定用の引数としては、本ライブラリの
`MIDIIn_OpenW` 関数または `MIDIIn_ReopenW` 関数の返り値以外は
指定しないでください。

引数となる `MIDIIn` 構造体の扱いについては別項目をご覧ください。

内部のキューに MIDI メッセージが溜まっていたら、
その先頭メッセージをキューから取り出してデータを返します。

MIDIIO ライブラリでは
「lLen は 256 バイト用意しておくべきである」
とあったり、MIDIIO ライブラリのソースを参照すると
最大で 4,096 バイトになっていたりするようですが、
本ライブラリではそのような制限がないため
もっと長いデータになる可能性があります。

バッファに入りきらなかった部分は切り詰められ、
二度と取得できなくなるのは MIDIIO ライブラリと同様です。

#### `MIDIOut` 構造体、`MIDIIn` 構造体

構造体のメンバは `m_pDeviceName` のみ設定されます。
その他のメンバには何も設定されません。

世界樹に対して（本ライブラリの外側に対して）は、
「`MIDIOut` 構造体へのポインタ」
「`MIDIIn` 構造体へのポインタ」
として見えるようにしていますが、
本ライブラリ内部ではこれら構造体から派生させたクラスとして扱っており、
本ライブラリで使うデータは派生クラスのメンバ変数にしています。

本ライブラリの
`MIDIOut_OpenW` 関数、`MIDIOut_ReopenW` 関数、
`MIDIIn_OpenW` 関数、`MIDIIn_ReopenW` 関数
（以下、 Open/Reopen 系関数と呼びます）
の返り値は、あくまでも
「`MIDIOut` 構造体へのポインタ」
「`MIDIIn` 構造体へのポインタ」
として扱い、
派生クラスのメンバ関数・メンバ変数にはアクセスしないでください。

本ライブラリの関数でこれらの構造体へのポインタを引数に持つものは、
内部で派生クラスへ `static_cast` によるダウンキャストをしています。
その引数には本ライブラリの Open/Reopen 系関数が返した
ポインタそのものだけを指定してください。
それ以外（例えば構造体をコピーした先のポインタとか、
自分でインスタンス化した構造体へのポインタとかなど）
は危険なダウンキャストになってしまいますので、おやめください。
本当は安全なダウンキャストをするために `static_cast` ではなく
`dynamic_cast` を使いたいところですが、
そのためには `MIDIOut` や `MIDIIn` が virtual 関数を持つ必要があり、
virtual 関数を持つとメモリレイアウトが変わってしまう
（処理系依存ですが、大抵は先頭に vtable へのポインタ vptr が入るようです）
ので難しいです。

### デバイスの名前、ID、表示名

MME MIDI ではデバイスを特定するための文字列は 1 種類だけで、
これを MIDIIO ライブラリでは「デバイス名」として扱っているようですが、
UWP MIDI では名前と ID の 2 種類の文字列があります。

UWP MIDI で MIDI デバイスを指定するには ID 文字列だけあればよいのですが、
人間が見ても何のデバイスを表しているのかまったくわからないので、
ID 文字列とは別に人間が見るための名前の文字列が用意されているようです。

UWP MIDI 化するには、
内部で名前の文字列と ID 文字列の組み合わせを保持しておき、
名前の文字列を「デバイス名」として扱い、
名前の文字列から ID 文字列を探せば良さそうに思います。
ところが、複数の MIDI デバイスで
名前の文字列が同じになってしまうことがあります。
これでは MIDI デバイスを一意に特定することができず
ポートを開くことができません。

一方の ID 文字列は必ず MIDI デバイスを一意に特定できるようになっています。
どうやっているのか、似たような MIDI デバイスの複数のポートの
ID 文字列を比較してみると、途中に含まれている 16 進数 8
桁の部分の違いで区別することができそうに見えます。

そこで、UWP MIDI が返してきた名前の文字列に、
ID 文字列から抽出した 16 進数 8 桁を角括弧で括って追加したものを
「表示名」文字列として用意し、
これを本ライブラリにおける「デバイス名」として扱うことにしました。

なお「Microsoft GS Wavetable Synth」は他の MIDI ポートとは異なり、
ID 文字列に 16 進数 8 桁部分が存在しません。
そのような ID 文字列のデバイスは、名前をそのまま表示名とします
（そういうデバイスは「Microsoft GS Wavetable Synth」以外には
見たことはありません）。

さらに、ナゼか MIDI OUT デバイスの名前が「MIDI」などになり、
本当の名前がわからなくなる事象があります。
MIDI IN と MIDI OUT が共通のデバイスになっていて
ID 文字列の 16 進数 8 桁部分が同じ場合に発生する事象のようです。
これは UWP MIDI 登場時から存在する事象のようで、
Windows 10 21H1 でもそのままになっています
（Windows 11 では直っているのか否か不明です）。

そこで、これに対処するため、MIDI IN と MIDI OUT で
16 進数 8 桁部分が同じ、かつ、MIDI OUT デバイスの名前が「MIDI」で
始まっている場合は、MIDI IN デバイスの表示名を
MIDI OUT デバイスの表示名に丸々コピーするようにしています。

### デバッグ版

MIDIIO ライブラリと同様、デバッグ版をビルドすると
`MIDIIOd.dll` というファイル名になります
（拡張子を除いたファイル名部分の最後に `d` が付きます）。

本ライブラリのデバッグ版は、本来必要が無い MFC のデバッグ版 DLL
`mfc140ud.dll` を（なかばムリヤリ）暗黙的リンクしています。
これはメモリリーク誤検出を避けるためです。

世界樹のデバッグ版をビルドし
本ライブラリのデバッグ版と組み合わせて動作させたところ、
その世界樹を終了させるときにデバッグメッセージへ
`Detected Memory Leaks!` というのが出て、
大量のメモリリークを指摘されるという事象が発生しました。
本ライブラリは `new` も `malloc` も使っていないため、
メモリリークといってもまったく心当たりがありません。
デストラクタが呼ばれればメモリは解放されるハズですし、
デストラクタは自動で呼ばれるハズです。

そこで、いくつかのデストラクタにデバッグメッセージを仕込んでみたところ、
なんと `Detected Memory Leaks!` の後で
デストラクタが呼ばれているではありませんか。
本ライブラリは、開いたポートに紐づかない情報を保持するため
static メンバ変数を利用しています。
C++ のグローバル変数や static メンバ変数のデストラクタは
プログラム終了時に呼び出されることになっているのですが、
その前にメモリリーク検出機構がキックされて
「まだ解放されていないメモリブロックがある！メモリリークだ！」
という指摘をされているらしい、ということがわかりました。

では、誰がメモリリーク検出機構をキックしているのかというと、
MFC のデバッグ版 DLL でした。
世界樹のデバッグ版は、MFC デバッグ版と本ライブラリのデバッグ版の
両方の DLL を暗黙的リンクしています。
で、終了時には DLL を解放するのですが、
MFC デバッグ版 DLL は解放される際にメモリリーク検出機構を
キックするようなのです。
つまり、本ライブラリより先に MFC が解放されており、
本ライブラリのデストラクタ群が呼び出される前に
メモリリーク検出機構をキックしてしまい、誤検出が発生しているのです。

誤検出なので無視すればよいといえばよいのですが、
本当にメモリリークしていたときに埋もれてしまってわからなくなります。
そこで、誤検出を避ける方法を模索してたどり着いたのが
本ライブラリに MFC の DLL をリンクしてしまう方法です。
これにより本ライブラリが MFC の DLL に依存していることになるので、
世界樹の終了時に本ライブラリの方が先に解放されるようになり、
本ライブラリのデストラクタ群が呼び出された後で
メモリリーク検出機構がキックされるので、誤検出がなくなるというわけです。

どうやってリンクすればよいか、かなり悩みました。
MFC を使っていないにヘッダファイルを #include
するといろいろおかしくなるので、呼び出してもあまり害の無さそうな関数を
1 つだけ自前でプロトタイプ宣言し、
あまり害の無さそうなタイミングでムダに呼ぶようにしています。

いずれにせよ、これはデバッグ版のみの機能になっており、
リリース版では発動しないようにしていますので影響ありません。
また、世界樹もバイナリ配布されているのはリリース版のみのようなので、
自分で世界樹をビルドしようとしない限り遭遇しない事象ではあります。

## UWP

BLE MIDI (Bluetooth MIDI) は Windows では UWP のみの対応、
従来の MME では扱うことができません。
UWP つまり Universal Windows Platform は
ストアアプリが使うものであって、
世界樹のような従来からあるデスクトップアプリとは完全に異なるもの、
と思っていました。

そうだとすると BLE MIDI に対応するには
ストアアプリの MIDI シーケンサ―が必要ということになります。一方、
Cakewake by BandLab ではドライバモードを MME から UWP に切り替えることができ、
UWP モードにすれば BLE MIDI が使えるようになる、という記事がありました。
Cakewake はストアアプリではなさそうなのに
一体どうやっているのか気になっていました。
当初は裏でストアアプリが動いていてプロセス間連携でもしているのかな、
とか思っていたのですが、
私自身 BLE MIDI デバイスを持っておらず
USB MIDI しか使っていなかったことから、
それ以上は特に気にしていませんでした。

ですが、諸々あって BLE MIDI デバイスを購入して使ってみることにしました。
世界樹で使うために購入したわけではないのですが、
モノがあると世界樹でも使えるようにしたいと思うようになり、
UWP MIDI について調べ始めました。

UWP MIDI 非対応のソフトウェアで BLE MIDI を使えるようにするためには、
MIDIberry というストアアプリと loopMIDI というドライバを
組み合わせる方法が広く使われているようです。
MIDIberry はストアアプリなので普通に UWP で MIDI を扱うことができ、
そのため BLE MIDI が扱えるということでしょう。

では、その UWP MIDI を扱うプログラムはどう作ればよいか。
Visual Studio で C# でストアアプリを作るのが一般的で、
そのための技術情報もいろいろ存在するようです。
やはりストアアプリでなければ使えないのかと思っていたところ、
[
普通の Win32 アプリケーションから UWP MIDI API を使えるようにする DLL
](https://github.com/stammen/winrtmidi)
を発見しました。
残念ながら何年も前に開発が止まってしまっていて
既にサポートされていませんでしたが、
やる方法はある、ということですね。
ここで分かったことは UWP MIDI と呼ばれているものは Windows Runtime (WinRT) の
Windows::Device::Midi API のことであるということです。

WinRT は、やはり C# から使うストアアプリ用の API 群という感じが強いですが、
[
Python から WinRT を使うモジュール
](https://pypi.org/project/winrt/)
があったりして、必ずしも C# 用というわけではありません。
試しに[
Python winrt で MIDI メッセージを転送するスクリプト
](https://gist.github.com/trueroad/6beaf87280afb2b5e33b4838d73be6ed)
を作ってみたところ、BLE MIDI デバイスを認識して、
ちゃんと MIDI メッセージの送受信もできました。
この機能を DLL 化できればよいわけですが、
それには C++ を使いたくなります。

C++ で WinRT を使うには、
かつて C++/CX とか WRL とかいうものがあったようです。
普通の C++ ではなくて、いろいろと独自拡張したもの、らしいですね。
ただやはり独自拡張というのが問題になりそうですし、
既に移行が推奨されているようで今からこれを選択するのはあり得ません。
そこで登場するのが[
C++/WinRT
](https://github.com/microsoft/cppwinrt)
になります。
これなら標準 C++17 規格の C++ コンパイラで使えるという触れ込みです
（実際には `co_await` など一部 C++20 規格の機能が必要になるようです）。

C++/WinRT は Visual Studio 2017 の途中のバージョン以降、
もしくは Visual Studio 2019 以降でサポートされているとのこと。
早速 Visual Studio Community 2019 で試してみることにしました。
Visual Studio の機能としては「C++ によるデスクトップ開発」
「ユニバーサル Windows プラットフォーム開発」
あたりを入れておけばよさそうです。
また、通常の C++/WinRT 開発をするならば拡張機能で
「C++/WinRT templates and visualizer for VS2019」
を入れておくと C++/WinRT 向けプロジェクトが作れるようになり、
便利そうです。

ただし、今回やりたいことは C++/WinRT
で普通のストアアプリを作りたいのではなく、
デスクトップアプリから UWP MIDI の API を使うことです。
そこで、まずは Python で作った MIDI メッセージ転送スクリプトを
C++/WinRT に移植してみることにしました。
コンソールアプリですね。
そうして作ったものが[
C++/WinRT で MIDI メッセージを転送する試み
](https://gist.github.com/trueroad/9c5317af5f212b2de7c7012e76b9e66b)
です。
これは Visual Studio Community 2019 を使いましたが、
C++/WinRT 向けプロジェクトではなく、
普通の C++ コンソールアプリとしてプロジェクトを作り、
そこで C++/WinRT が使えるようにプロジェクトの設定変更をして
実装を作り込んでいったものです。
Python とはだいぶ勝手が違うところはありましたが、
こちらでも BLE MIDI デバイスを認識して
MIDI メッセージを送受信することができるようになりました。

ここまでできれば DLL 化も目前です。
世界樹が使っている MIDIIO ライブラリについて、また、
世界樹のソースを参照して MIDIIO ライブラリをどのように使っているかについて、
などを調べることにより MIDIIO ライブラリと API 互換で
UWP MIDI を使う本ライブラリを作ることができました。

## ライセンス

Copyright (C) 2022 Masamichi Hosoda. All rights reserved.

License: BSD-2-Clause

[LICENSE](./LICENSE) をご覧ください。
